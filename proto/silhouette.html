<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Body Silhouette — Prototype</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, "Segoe UI", Roboto, sans-serif;
    background: #f8f8f6;
    color: #333;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 24px 16px;
  }
  h1 { font-size: 18px; font-weight: 600; margin-bottom: 16px; }

  .container {
    display: flex;
    gap: 12px;
    align-items: flex-start;
    justify-content: center;
    width: 100%;
    max-width: 560px;
  }
  .view-col {
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: 240px;
    flex: 1;
  }
  .view-col svg { width: 100%; height: auto; }
  .view-label {
    margin-top: 4px;
    font-size: 12px;
    color: #888;
  }

  /* Silhouette styles */
  .si-body { stroke: #6b6b6b; }
  .si-stroke { fill: none; stroke: #6b6b6b; }
  .si-dot { fill: #6b6b6b; opacity: 0.3; }
  .ml-line { stroke: #bbbbbb; }
  .ml-line.active { stroke: #c05050; }
  .ml-cap { stroke: #bbbbbb; }
  .ml-cap.active { stroke: #c05050; }
  .ml-label { fill: #bbbbbb; font-family: -apple-system, "Segoe UI", Roboto, sans-serif; }
  .ml-label.active { fill: #c05050; }
  .ml-group { cursor: pointer; }

  /* Size slider */
  .controls {
    margin-top: 20px;
    display: flex;
    align-items: center;
    gap: 12px;
    font-size: 14px;
  }
  .controls input[type=range] { width: 200px; }
  .size-label { font-weight: 600; min-width: 80px; text-align: center; }
</style>
</head>
<body>
<h1>Body Silhouette</h1>
<div class="container" id="container"></div>
<div class="controls">
  <span>T34</span>
  <input type="range" id="sizeSlider" min="34" max="48" step="2" value="38" />
  <span>T48</span>
  <span class="size-label" id="sizeLabel">T38 (M)</span>
</div>

<script>
// ── Size table (base at T38, increment per size step of 2) ──
const SIZE_TABLE = {
  back_waist_length: [41.0, 0.5],
  front_waist_length: [37.0, 0.5],
  full_bust: [88.0, 4.0],
  bust_height: [22.0, 0.5],
  half_bust_point_distance: [9.25, 0.25],
  full_waist: [68.0, 4.0],
  small_hip: [85.0, 4.0],
  full_hip: [94.0, 4.0],
  neck_circumference: [36.0, 1.0],
  half_back_width: [17.5, 0.25],
  half_front_width: [16.5, 0.25],
  shoulder_length: [12.0, 0.4],
  armhole_circumference: [39.5, 1.0],
  underarm_height: [21.5, 0.25],
  arm_length: [60.0, 0.0],
  upper_arm: [26.0, 1.0],
  elbow_height: [35.0, 0.0],
  wrist: [16.0, 0.25],
  waist_to_hip: [22.0, 0.0],
  crotch_depth: [26.5, 0.5],
  crotch_length: [60.0, 2.0],
  waist_to_knee: [58.0, 1.0],
  waist_to_floor: [105.0, 0.5],
  side_waist_to_floor: [105.5, 1.0],
};

const SIZE_LABELS = {
  34: "T34 (XS)", 36: "T36 (S)", 38: "T38 (M)", 40: "T40 (M/L)",
  42: "T42 (L)", 44: "T44 (XL)", 46: "T46 (XXL)", 48: "T48 (XXXL)",
};

// Field display order (for numbering)
const ALL_FIELDS = [
  "back_waist_length", "front_waist_length",
  "full_bust", "bust_height", "half_bust_point_distance", "full_waist", "small_hip", "full_hip", "neck_circumference",
  "half_back_width", "half_front_width", "shoulder_length",
  "armhole_circumference", "underarm_height", "arm_length", "upper_arm", "elbow_height", "wrist",
  "waist_to_hip", "crotch_depth", "crotch_length", "waist_to_knee", "waist_to_floor", "side_waist_to_floor",
];
const FIELD_NUM = {};
ALL_FIELDS.forEach((f, i) => { FIELD_NUM[f] = i + 1; });

function computeValues(size) {
  const diff = (size - 38) / 2;
  const v = {};
  for (const [key, [base, incr]] of Object.entries(SIZE_TABLE)) {
    v[key] = +(base + incr * diff).toFixed(2);
  }
  return v;
}

// ── Geometry computation ──
function computeGeometry(v) {
  const totalBodyH = v.waist_to_floor + v.back_waist_length;
  const scale = 420 / totalBodyH;
  const cx = 160;
  const pt = (x, y) => `${x.toFixed(1)},${y.toFixed(1)}`;

  const headR = 22;
  const headCy = 40;
  const neckBase = headCy + headR + 8;
  const shoulderY = neckBase + 6;
  const waistY = shoulderY + v.back_waist_length * scale;
  const bustY = shoulderY + v.bust_height * scale;
  const smallHipY = waistY + v.waist_to_hip * 0.6 * scale;
  const hipY = waistY + v.waist_to_hip * scale;
  const crotchY = waistY + v.crotch_depth * scale;
  const kneeY = waistY + v.waist_to_knee * scale;
  const floorY = waistY + v.waist_to_floor * scale;

  const neckHW = (v.neck_circumference / Math.PI) * scale * 0.5;
  const shoulderHW = (v.half_back_width + v.shoulder_length) * scale * 0.52;
  const bustHW = (v.full_bust / Math.PI) * scale * 0.55;
  const waistHW = (v.full_waist / Math.PI) * scale * 0.55;
  const smallHipHW = (v.small_hip / Math.PI) * scale * 0.55;
  const hipHW = (v.full_hip / Math.PI) * scale * 0.55;
  const upperArmW = (v.upper_arm / Math.PI) * scale * 0.5;
  const wristW = (v.wrist / Math.PI) * scale * 0.5;
  const halfBackW = v.half_back_width * scale * 0.52;
  const halfFrontW = v.half_front_width * scale * 0.52;

  const thighHW = hipHW * 0.38;
  const kneeHW = thighHW * 0.7;
  const ankleHW = wristW * 0.8;
  const legGap = thighHW * 0.3;

  const armLen = v.arm_length * scale;
  const elbowLen = v.elbow_height * scale;
  const elbowY = shoulderY + elbowLen;
  const wristY = shoulderY + armLen;
  const armAngle = (12 * Math.PI) / 180;
  const armDx = Math.sin(armAngle);
  const armDy = Math.cos(armAngle);

  const headRx = headR * 0.78;

  // ── Hair ──
  // Front hair: arc framing the top of the head with a center part
  const frontHairD = [
    `M${cx - headR * 0.7} ${headCy - headR * 0.3}`,
    `Q${cx - headR * 0.85} ${headCy - headR * 1.1} ${cx} ${headCy - headR * 1.15}`,
    `Q${cx + headR * 0.85} ${headCy - headR * 1.1} ${cx + headR * 0.7} ${headCy - headR * 0.3}`,
    `M${cx} ${headCy - headR * 1.15} L${cx} ${headCy - headR * 0.8}`,
  ].join(" ");

  // Back hair: bun shape — a small filled oval on top and hairline framing back of head
  const bunCy = headCy - headR * 0.95;
  const bunRx = headR * 0.35;
  const bunRy = headR * 0.3;
  const backHairD = [
    // Hairline framing the back of the head
    `M${cx - headR * 0.65} ${headCy - headR * 0.1}`,
    `Q${cx - headR * 0.8} ${headCy - headR * 0.9} ${cx} ${headCy - headR * 1.05}`,
    `Q${cx + headR * 0.8} ${headCy - headR * 0.9} ${cx + headR * 0.65} ${headCy - headR * 0.1}`,
  ].join(" ");

  // ── Face (front view only) ──
  const eyeY = headCy - 3;
  const eyeSpacing = headRx * 0.4;
  const faceD = [
    // Left eye
    `M${cx - eyeSpacing - 3} ${eyeY} Q${cx - eyeSpacing} ${eyeY - 2.5} ${cx - eyeSpacing + 3} ${eyeY}`,
    // Right eye
    `M${cx + eyeSpacing - 3} ${eyeY} Q${cx + eyeSpacing} ${eyeY - 2.5} ${cx + eyeSpacing + 3} ${eyeY}`,
    // Nose
    `M${cx} ${eyeY + 3} L${cx} ${eyeY + 8}`,
    // Mouth
    `M${cx - 3} ${eyeY + 11} Q${cx} ${eyeY + 13} ${cx + 3} ${eyeY + 11}`,
  ].join(" ");

  // Bun ellipse data (rendered separately as filled shape)
  const bun = { cx, cy: bunCy, rx: bunRx, ry: bunRy };

  const neckD = [
    `M${cx - neckHW} ${headCy + headR - 2} L${cx - neckHW} ${neckBase}`,
    `M${cx + neckHW} ${headCy + headR - 2} L${cx + neckHW} ${neckBase}`,
  ].join(" ");

  // Front torso (with bust bump)
  const torsoD = [
    `M${pt(cx - neckHW, neckBase)}`,
    `Q${pt(cx - neckHW - 4, shoulderY - 2)} ${pt(cx - shoulderHW, shoulderY)}`,
    `Q${pt(cx - shoulderHW + 2, shoulderY + 8)} ${pt(cx - bustHW + 2, bustY - 8)}`,
    `Q${pt(cx - bustHW - 1, bustY)} ${pt(cx - bustHW, bustY + 4)}`,
    `Q${pt(cx - bustHW + 4, (bustY + waistY) / 2)} ${pt(cx - waistHW, waistY)}`,
    `Q${pt(cx - waistHW - 2, (waistY + smallHipY) / 2)} ${pt(cx - smallHipHW, smallHipY)}`,
    `Q${pt(cx - hipHW - 1, (smallHipY + hipY) / 2)} ${pt(cx - hipHW, hipY)}`,
    `Q${pt(cx - hipHW + 2, (hipY + crotchY) / 2)} ${pt(cx - legGap - thighHW * 2, crotchY)}`,
    `L${pt(cx - legGap, crotchY)}`,
    `M${pt(cx + legGap, crotchY)}`,
    `L${pt(cx + legGap + thighHW * 2, crotchY)}`,
    `Q${pt(cx + hipHW + 2, (hipY + crotchY) / 2)} ${pt(cx + hipHW, hipY)}`,
    `Q${pt(cx + hipHW + 1, (smallHipY + hipY) / 2)} ${pt(cx + smallHipHW, smallHipY)}`,
    `Q${pt(cx + waistHW + 2, (waistY + smallHipY) / 2)} ${pt(cx + waistHW, waistY)}`,
    `Q${pt(cx + bustHW - 4, (bustY + waistY) / 2)} ${pt(cx + bustHW, bustY + 4)}`,
    `Q${pt(cx + bustHW + 1, bustY)} ${pt(cx + bustHW - 2, bustY - 8)}`,
    `Q${pt(cx + shoulderHW - 2, shoulderY + 8)} ${pt(cx + shoulderHW, shoulderY)}`,
    `Q${pt(cx + neckHW + 4, shoulderY - 2)} ${pt(cx + neckHW, neckBase)}`,
  ].join(" ");

  // Back torso (smooth, no bust bump)
  const backTorsoD = [
    `M${pt(cx - neckHW, neckBase)}`,
    `Q${pt(cx - neckHW - 4, shoulderY - 2)} ${pt(cx - shoulderHW, shoulderY)}`,
    `Q${pt(cx - shoulderHW + 2, (shoulderY + bustY) / 2)} ${pt(cx - bustHW + 4, bustY)}`,
    `Q${pt(cx - bustHW + 6, (bustY + waistY) / 2)} ${pt(cx - waistHW, waistY)}`,
    `Q${pt(cx - waistHW - 2, (waistY + smallHipY) / 2)} ${pt(cx - smallHipHW, smallHipY)}`,
    `Q${pt(cx - hipHW - 1, (smallHipY + hipY) / 2)} ${pt(cx - hipHW, hipY)}`,
    `Q${pt(cx - hipHW + 2, (hipY + crotchY) / 2)} ${pt(cx - legGap - thighHW * 2, crotchY)}`,
    `L${pt(cx - legGap, crotchY)}`,
    `M${pt(cx + legGap, crotchY)}`,
    `L${pt(cx + legGap + thighHW * 2, crotchY)}`,
    `Q${pt(cx + hipHW + 2, (hipY + crotchY) / 2)} ${pt(cx + hipHW, hipY)}`,
    `Q${pt(cx + hipHW + 1, (smallHipY + hipY) / 2)} ${pt(cx + smallHipHW, smallHipY)}`,
    `Q${pt(cx + waistHW + 2, (waistY + smallHipY) / 2)} ${pt(cx + waistHW, waistY)}`,
    `Q${pt(cx + bustHW - 6, (bustY + waistY) / 2)} ${pt(cx + bustHW - 4, bustY)}`,
    `Q${pt(cx + shoulderHW - 2, (shoulderY + bustY) / 2)} ${pt(cx + shoulderHW, shoulderY)}`,
    `Q${pt(cx + neckHW + 4, shoulderY - 2)} ${pt(cx + neckHW, neckBase)}`,
  ].join(" ");

  // Bust darts (front only)
  const bpd = v.half_bust_point_distance * scale;
  const bustDartL = `M${cx - bpd - 4} ${bustY - 5} Q${cx - bpd} ${bustY + 5} ${cx - bpd + 4} ${bustY - 5}`;
  const bustDartR = `M${cx + bpd - 4} ${bustY - 5} Q${cx + bpd} ${bustY + 5} ${cx + bpd + 4} ${bustY - 5}`;

  // Legs
  function buildLeg(outerX, innerX, legCx) {
    const kO = outerX < cx ? -1 : 1;
    return [
      `M${pt(outerX, crotchY)}`,
      `Q${pt(legCx + kO * (kneeHW + 2), (crotchY + kneeY) / 2)} ${pt(legCx + kO * kneeHW, kneeY)}`,
      `Q${pt(legCx + kO * (ankleHW + 1), (kneeY + floorY) / 2)} ${pt(legCx + kO * ankleHW, floorY)}`,
      `L${pt(legCx - kO * ankleHW, floorY)}`,
      `Q${pt(legCx - kO * (ankleHW + 1), (kneeY + floorY) / 2)} ${pt(legCx - kO * kneeHW, kneeY)}`,
      `Q${pt(legCx - kO * (kneeHW + 2), (crotchY + kneeY) / 2)} ${pt(innerX, crotchY)}`,
    ].join(" ");
  }

  const lLO = cx - legGap - thighHW * 2;
  const lLI = cx - legGap;
  const lLCx = (lLO + lLI) / 2;
  const rLO = cx + legGap + thighHW * 2;
  const rLI = cx + legGap;
  const rLCx = (rLO + rLI) / 2;

  const footRx = ankleHW * 2.2;
  const footRy = 6;
  const footCy = floorY + footRy / 2;

  // ── Hanging arms (back view) ──
  function buildArm(side) {
    const s = side === "left" ? -1 : 1;
    const sx = cx + s * shoulderHW;
    const sy = shoulderY;
    const elX = sx + s * armDx * (elbowY - sy);
    const elY = sy + armDy * (elbowY - sy);
    const wrX = sx + s * armDx * (wristY - sy);
    const wrY = sy + armDy * (wristY - sy);
    const uaW = upperArmW;
    const elbW = upperArmW * 0.75;
    const wrW = wristW;
    const px = armDy;
    const py = -armDx;

    const armD = [
      `M${pt(sx + px * uaW, sy + py * uaW)}`,
      `Q${pt((sx + elX) / 2 + px * uaW, (sy + elY) / 2 + py * uaW)} ${pt(elX + px * elbW, elY + py * elbW)}`,
      `Q${pt((elX + wrX) / 2 + px * elbW * 0.7, (elY + wrY) / 2 + py * elbW * 0.7)} ${pt(wrX + px * wrW, wrY + py * wrW)}`,
      `Q${pt(wrX, wrY + 3)} ${pt(wrX - px * wrW, wrY - py * wrW)}`,
      `Q${pt((elX + wrX) / 2 - px * elbW * 0.7, (elY + wrY) / 2 - py * elbW * 0.7)} ${pt(elX - px * elbW, elY - py * elbW)}`,
      `Q${pt((sx + elX) / 2 - px * uaW, (sy + elY) / 2 - py * uaW)} ${pt(sx - px * uaW, sy - py * uaW)}`,
    ].join(" ");

    const handR = wrW * 1.1;
    return { armD, hand: { cx: wrX, cy: wrY + handR * 0.8, rx: handR * 0.85, ry: handR } };
  }

  // ── Akimbo arms (front view) — hands on hips ──
  function buildArmAkimbo(side) {
    const s = side === "left" ? -1 : 1;
    const sx = cx + s * shoulderHW;
    const sy = shoulderY;

    // 40° from vertical — natural akimbo angle
    const angle = 40 * Math.PI / 180;
    const sinA = Math.sin(angle);
    const cosA = Math.cos(angle);

    // Elbow position along center of arm
    const elCx = sx + s * elbowLen * sinA;
    const elCy = sy + elbowLen * cosA;

    // Hand center at hip
    const hx = cx + s * (waistHW + 2);
    const hy = waistY;

    // Arm half-widths (thinner than anatomical for fashion illustration look)
    const w0 = upperArmW * 0.65;  // shoulder
    const w1 = upperArmW * 0.45;  // elbow
    const w2 = wristW * 0.45;     // wrist

    // Upper arm perpendicular: outer = away from body (upward for akimbo)
    // Direction (s*sinA, cosA); outer perp = (s*cosA, -sinA)
    const ua_ox = s * cosA, ua_oy = -sinA;

    // Forearm perpendicular: pick the one pointing upward (y < 0)
    const fdx = hx - elCx, fdy = hy - elCy;
    const fl = Math.sqrt(fdx * fdx + fdy * fdy);
    const fnx = fdx / fl, fny = fdy / fl;
    let fa_ox = fny, fa_oy = -fnx;
    if (fa_oy > 0) { fa_ox = -fa_ox; fa_oy = -fa_oy; }

    // Key outline points
    const sTop  = { x: sx   + ua_ox * w0, y: sy   + ua_oy * w0 };
    const sBot  = { x: sx   - ua_ox * w0, y: sy   - ua_oy * w0 };
    const eUaT  = { x: elCx + ua_ox * w1, y: elCy + ua_oy * w1 };  // elbow, upper arm top
    const eUaB  = { x: elCx - ua_ox * w1, y: elCy - ua_oy * w1 };  // elbow, upper arm bottom
    const eFaT  = { x: elCx + fa_ox * w1, y: elCy + fa_oy * w1 };  // elbow, forearm top
    const eFaB  = { x: elCx - fa_ox * w1, y: elCy - fa_oy * w1 };  // elbow, forearm bottom
    const wTop  = { x: hx   + fa_ox * w2, y: hy   + fa_oy * w2 };
    const wBot  = { x: hx   - fa_ox * w2, y: hy   - fa_oy * w2 };

    // Outer contour: shoulder top → elbow outer (pointy) → wrist bottom
    // The outer silhouette crosses from ua_top to fa_bottom at the pointy elbow
    // Inner contour: wrist top → elbow inner (crook) → shoulder bottom
    // The inner silhouette crosses from fa_top to ua_bottom at the crook

    // Pointy elbow apex — slightly beyond the elbow center
    const apexX = elCx + s * w1 * 1.6;
    const apexY = elCy;
    // Elbow crook — slightly inward
    const crookX = elCx - s * w1 * 0.3;
    const crookY = elCy;

    const armD = [
      // Outer contour: shoulder → pointy elbow → wrist
      `M${pt(sTop.x, sTop.y)}`,
      `Q${pt((sTop.x + eUaT.x) / 2 + ua_ox * w0, (sTop.y + eUaT.y) / 2 + ua_oy * w0)} ${pt(eUaT.x, eUaT.y)}`,
      `Q${pt(apexX, apexY)} ${pt(eFaB.x, eFaB.y)}`,
      `Q${pt((eFaB.x + wBot.x) / 2 - fa_ox * w1, (eFaB.y + wBot.y) / 2 - fa_oy * w1)} ${pt(wBot.x, wBot.y)}`,
      // Wrist cap
      `Q${pt(hx + fnx * 3, hy + fny * 3)} ${pt(wTop.x, wTop.y)}`,
      // Inner contour: wrist → crook → shoulder
      `Q${pt((wTop.x + eFaT.x) / 2 + fa_ox * w1, (wTop.y + eFaT.y) / 2 + fa_oy * w1)} ${pt(eFaT.x, eFaT.y)}`,
      `Q${pt(crookX, crookY)} ${pt(eUaB.x, eUaB.y)}`,
      `Q${pt((eUaB.x + sBot.x) / 2 - ua_ox * w0, (eUaB.y + sBot.y) / 2 - ua_oy * w0)} ${pt(sBot.x, sBot.y)}`,
    ].join(" ");

    const handR = w2 * 1.5;
    return {
      armD,
      hand: { cx: hx, cy: hy, rx: handR, ry: handR * 0.85 },
      elbowX: elCx,
      elbowY: elCy,
    };
  }

  const backArms = { left: buildArm("left"), right: buildArm("right") };
  const frontArms = { left: buildArmAkimbo("left"), right: buildArmAkimbo("right") };

  const navelCy = waistY + (hipY - waistY) * 0.15;

  // Underarm Y: where the armhole meets the side body (roughly bustY level)
  const underarmY = bustY + 4;

  // Hanging arm wrist X position (left side, for back view arm_length measurement)
  const hangLwrX = cx - shoulderHW - armDx * armLen;

  // ── Measurement lines — back (11) ──
  const backMeasureLines = [
    { type: "v", field: "back_waist_length", y1: shoulderY, y2: waistY, x: cx + bustHW + 22 },
    { type: "h", field: "full_bust", y: bustY, x1: cx - bustHW - 15, x2: cx + bustHW + 15 },
    { type: "h", field: "full_waist", y: waistY, x1: cx - waistHW - 15, x2: cx + waistHW + 15 },
    { type: "h", field: "small_hip", y: smallHipY, x1: cx - smallHipHW - 12, x2: cx + smallHipHW + 12 },
    { type: "h", field: "full_hip", y: hipY, x1: cx - hipHW - 15, x2: cx + hipHW + 15 },
    { type: "h", field: "half_back_width", y: shoulderY + 14, x1: cx - halfBackW, x2: cx + halfBackW },
    { type: "h", field: "upper_arm", y: shoulderY + 20, x1: cx - shoulderHW - upperArmW - 8, x2: cx - shoulderHW + upperArmW + 2 },
    { type: "v", field: "arm_length", y1: shoulderY, y2: wristY, x: hangLwrX - wristW - 8 },
    { type: "v", field: "waist_to_hip", y1: waistY, y2: hipY, x: cx + hipHW + 20 },
    { type: "v", field: "crotch_depth", y1: waistY, y2: crotchY, x: cx - hipHW - 18 },
    { type: "v", field: "crotch_length", y1: waistY - 8, y2: crotchY + 8, x: cx },
  ];

  // ── Measurement lines — front (13) ──
  const akR = frontArms.right;

  // Armhole arc: small curved indicator around the armhole area (right side)
  const ahCx = cx + shoulderHW - 4;
  const ahCy = shoulderY + 10;
  const ahR = 12;
  const armholeArcD = [
    `M${pt(ahCx + ahR * 0.7, ahCy - ahR * 0.7)}`,
    `Q${pt(ahCx + ahR, ahCy)} ${pt(ahCx + ahR * 0.7, ahCy + ahR * 0.7)}`,
    `Q${pt(ahCx, ahCy + ahR)} ${pt(ahCx - ahR * 0.5, ahCy + ahR * 0.7)}`,
  ].join(" ");

  const frontMeasureLines = [
    { type: "v", field: "front_waist_length", y1: shoulderY, y2: waistY, x: cx - bustHW - 22 },
    { type: "v", field: "bust_height", y1: shoulderY, y2: bustY, x: cx - bustHW - 18 },
    { type: "h", field: "half_bust_point_distance", y: bustY + 2, x1: cx - bpd, x2: cx + bpd },
    { type: "h", field: "neck_circumference", y: neckBase - 2, x1: cx - neckHW - 12, x2: cx + neckHW + 12 },
    { type: "h", field: "half_front_width", y: shoulderY + 10, x1: cx - halfFrontW, x2: cx + halfFrontW },
    { type: "h", field: "shoulder_length", y: shoulderY, x1: cx - shoulderHW - 12, x2: cx + shoulderHW + 12 },
    { type: "arc", field: "armhole_circumference", d: armholeArcD, labelX: ahCx + ahR + 4, labelY: ahCy + 3 },
    { type: "v", field: "underarm_height", y1: underarmY, y2: waistY, x: cx + bustHW + 8 },
    { type: "h", field: "elbow_height", y: akR.elbowY, x1: akR.elbowX - 8, x2: akR.elbowX + 8 },
    { type: "h", field: "wrist", y: akR.hand.cy, x1: akR.hand.cx - wristW - 4, x2: akR.hand.cx + wristW + 4 },
    { type: "h", field: "waist_to_knee", y: kneeY, x1: cx - kneeHW - 20, x2: cx + kneeHW + 20 },
    { type: "h", field: "waist_to_floor", y: floorY, x1: cx - ankleHW - 30, x2: cx + ankleHW + 30 },
    { type: "v", field: "side_waist_to_floor", y1: waistY, y2: floorY, x: cx + hipHW + 20 },
  ];

  // ── ViewBox ──
  const minY = headCy - headR * 1.2 - 10;
  const maxY = floorY + 16;
  const svgH = maxY - minY;

  // Wider to accommodate akimbo elbows
  const akL = frontArms.left;
  const maxElbowX = Math.max(Math.abs(akR.elbowX - cx), Math.abs(akL.elbowX - cx));
  const svgW = Math.max(320, (maxElbowX + upperArmW + 30) * 2);
  const svgX = cx - svgW / 2;

  return {
    viewBox: `${svgX.toFixed(0)} ${minY.toFixed(0)} ${svgW.toFixed(0)} ${svgH.toFixed(0)}`,
    cx, head: { cx, cy: headCy, rx: headRx, ry: headR },
    frontHairD, backHairD, bun, faceD,
    neckD, torsoD, backTorsoD, bustDartL, bustDartR,
    leftLegD: buildLeg(lLO, lLI, lLCx),
    rightLegD: buildLeg(rLO, rLI, rLCx),
    feet: [
      { cx: lLCx, cy: footCy, rx: footRx, ry: footRy },
      { cx: rLCx, cy: footCy, rx: footRx, ry: footRy },
    ],
    backArms, frontArms,
    navel: { cx, cy: navelCy },
    backMeasureLines, frontMeasureLines,
  };
}

// ── SVG rendering ──

function renderMeasureLine(line, cx, active) {
  const num = FIELD_NUM[line.field];
  const sw = active ? 2 : 0.8;
  const dash = active ? "" : "4 3";
  const opacity = active ? 1 : 0.5;
  const fontWeight = active ? 700 : 400;
  const lblOpacity = active ? 1 : 0.7;
  const lineCls = active ? "ml-line active" : "ml-line";
  const capCls = active ? "ml-cap active" : "ml-cap";
  const lblCls = active ? "ml-label active" : "ml-label";

  let svg = `<g class="ml-group" data-field="${line.field}">`;

  if (line.type === "h") {
    svg += `<line x1="${line.x1}" y1="${line.y}" x2="${line.x2}" y2="${line.y}" stroke="transparent" stroke-width="10"/>`;
    svg += `<line x1="${line.x1}" y1="${line.y}" x2="${line.x2}" y2="${line.y}" class="${lineCls}" stroke-width="${sw}" stroke-dasharray="${dash}" opacity="${opacity}"/>`;
    svg += `<text x="${line.x2 + 4}" y="${line.y + 3}" font-size="9" class="${lblCls}" font-weight="${fontWeight}" opacity="${lblOpacity}">${num}</text>`;
  } else if (line.type === "arc") {
    svg += `<path d="${line.d}" stroke="transparent" fill="none" stroke-width="10"/>`;
    svg += `<path d="${line.d}" class="${lineCls}" fill="none" stroke-width="${sw}" stroke-dasharray="${dash}" opacity="${opacity}"/>`;
    svg += `<text x="${line.labelX}" y="${line.labelY}" font-size="9" class="${lblCls}" font-weight="${fontWeight}" opacity="${lblOpacity}">${num}</text>`;
  } else {
    const capSz = 3;
    const labelX = line.x > cx ? line.x + 6 : line.x - 8;
    const labelY = (line.y1 + line.y2) / 2 + 3;
    svg += `<line x1="${line.x}" y1="${line.y1}" x2="${line.x}" y2="${line.y2}" stroke="transparent" stroke-width="10"/>`;
    svg += `<line x1="${line.x}" y1="${line.y1}" x2="${line.x}" y2="${line.y2}" class="${lineCls}" stroke-width="${sw}" stroke-dasharray="${dash}" opacity="${opacity}"/>`;
    svg += `<line x1="${line.x - capSz}" y1="${line.y1}" x2="${line.x + capSz}" y2="${line.y1}" class="${capCls}" stroke-width="${sw}" opacity="${opacity}"/>`;
    svg += `<line x1="${line.x - capSz}" y1="${line.y2}" x2="${line.x + capSz}" y2="${line.y2}" class="${capCls}" stroke-width="${sw}" opacity="${opacity}"/>`;
    svg += `<text x="${labelX}" y="${labelY}" font-size="9" class="${lblCls}" font-weight="${fontWeight}" opacity="${lblOpacity}">${num}</text>`;
  }

  svg += `</g>`;
  return svg;
}

function renderView(viewId, geo, measureLines, activeField) {
  const gradId = `bodyGrad-${viewId}`;
  const torsoPath = viewId === "front" ? geo.torsoD : geo.backTorsoD;
  const fill = `url(#${gradId})`;
  const arms = viewId === "front" ? geo.frontArms : geo.backArms;
  const hairPath = viewId === "front" ? geo.frontHairD : geo.backHairD;

  let svg = `<svg viewBox="${geo.viewBox}" xmlns="http://www.w3.org/2000/svg" style="width:100%;height:auto;filter:drop-shadow(0 2px 8px rgba(0,0,0,0.06))">`;
  svg += `<defs><linearGradient id="${gradId}" x1="0" y1="0" x2="1" y2="1">`;
  svg += `<stop offset="0%" stop-color="#fdf6ee"/><stop offset="100%" stop-color="#f0e6d6"/>`;
  svg += `</linearGradient></defs>`;

  // Head
  svg += `<ellipse cx="${geo.head.cx}" cy="${geo.head.cy}" rx="${geo.head.rx}" ry="${geo.head.ry}" class="si-body" fill="${fill}" stroke-width="1.5"/>`;

  // Hair (view-specific)
  svg += `<path d="${hairPath}" class="si-stroke" stroke-width="1.2"/>`;
  // Bun (back view only)
  if (viewId === "back") {
    svg += `<ellipse cx="${geo.bun.cx}" cy="${geo.bun.cy}" rx="${geo.bun.rx}" ry="${geo.bun.ry}" class="si-body" fill="${fill}" stroke-width="1.2"/>`;
  }

  // Face (front view only)
  if (viewId === "front") {
    svg += `<path d="${geo.faceD}" class="si-stroke" stroke-width="0.8" opacity="0.5"/>`;
  }

  // Neck
  svg += `<path d="${geo.neckD}" class="si-stroke" stroke-width="1.5"/>`;
  // Torso
  svg += `<path d="${torsoPath}" class="si-body" fill="${fill}" stroke-width="1.5" stroke-linejoin="round"/>`;

  // Bust darts (front only)
  if (viewId === "front") {
    svg += `<path d="${geo.bustDartL}" class="si-stroke" stroke-width="0.8" opacity="0.5"/>`;
    svg += `<path d="${geo.bustDartR}" class="si-stroke" stroke-width="0.8" opacity="0.5"/>`;
  }

  // Legs
  svg += `<path d="${geo.leftLegD}" class="si-body" fill="${fill}" stroke-width="1.5" stroke-linejoin="round"/>`;
  svg += `<path d="${geo.rightLegD}" class="si-body" fill="${fill}" stroke-width="1.5" stroke-linejoin="round"/>`;

  // Feet
  for (const f of geo.feet) {
    svg += `<ellipse cx="${f.cx}" cy="${f.cy}" rx="${f.rx}" ry="${f.ry}" class="si-body" fill="${fill}" stroke-width="1.2"/>`;
  }

  // Arms (view-specific: hanging for back, akimbo for front)
  svg += `<path d="${arms.left.armD}" class="si-body" fill="${fill}" stroke-width="1.3" stroke-linejoin="round"/>`;
  svg += `<path d="${arms.right.armD}" class="si-body" fill="${fill}" stroke-width="1.3" stroke-linejoin="round"/>`;

  // Hands
  svg += `<ellipse cx="${arms.left.hand.cx}" cy="${arms.left.hand.cy}" rx="${arms.left.hand.rx}" ry="${arms.left.hand.ry}" class="si-body" fill="${fill}" stroke-width="1"/>`;
  svg += `<ellipse cx="${arms.right.hand.cx}" cy="${arms.right.hand.cy}" rx="${arms.right.hand.rx}" ry="${arms.right.hand.ry}" class="si-body" fill="${fill}" stroke-width="1"/>`;

  // Navel (front only)
  if (viewId === "front") {
    svg += `<circle cx="${geo.navel.cx}" cy="${geo.navel.cy}" r="1.5" class="si-dot"/>`;
  }

  // Measurement lines
  for (const line of measureLines) {
    svg += renderMeasureLine(line, geo.cx, activeField === line.field);
  }

  svg += `</svg>`;
  return svg;
}

// ── State & render loop ──

let activeField = null;
let currentSize = 38;

function render() {
  const values = computeValues(currentSize);
  const geo = computeGeometry(values);

  const container = document.getElementById("container");
  container.innerHTML = `
    <div class="view-col">
      ${renderView("back", geo, geo.backMeasureLines, activeField)}
      <span class="view-label">Back view</span>
    </div>
    <div class="view-col">
      ${renderView("front", geo, geo.frontMeasureLines, activeField)}
      <span class="view-label">Front view</span>
    </div>
  `;

  // Bind hover/click on measure line groups
  container.querySelectorAll(".ml-group").forEach(g => {
    const field = g.dataset.field;
    g.addEventListener("mouseenter", () => { activeField = field; render(); });
    g.addEventListener("mouseleave", () => { activeField = null; render(); });
  });
}

// Size slider
const slider = document.getElementById("sizeSlider");
const label = document.getElementById("sizeLabel");
slider.addEventListener("input", () => {
  currentSize = parseInt(slider.value);
  label.textContent = SIZE_LABELS[currentSize];
  render();
});

render();
</script>
</body>
</html>
